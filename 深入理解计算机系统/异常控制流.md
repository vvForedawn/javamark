## 异常控制流

1.进程切换是由硬件计时器和操作系统共同实现的，而信号则只是操作系统层面的概念了，到了非本地跳转就已经是在 C 运行时库中实现的了。

2.同步异常(Synchronous Exception)是因为执行某条指令所导致的事件，分为陷阱(Trap)、故障(Fault)和终止(Abort)三种情况。

| 类型   |     原因|       行为 |    示例|
|:--------|---------:|:-------:|:-------:|
|陷阱	|有意的异常	|返回到下一条指令	|系统调用，断点|
|故障	|潜在可恢复的错误	|返回到当前指令|页故障(page faults)|
|终止	|不可恢复的错误	|终止当前程序|	非法指令|
这里需要注意三种不同类型的处理方式，比方说陷阱和中断一样，会返回执行『下一条』指令；而故障会重新执行之前触发事件的指令；终止则是直接退出当前的程序。

3.在IA32系统上，系统调用是通过一条称为int n的陷阱指令来提供的。

4.进程给每个应用提供了两个非常关键的抽象：一是逻辑控制流，二是私有地址空间。逻辑控制流通过称为上下文切换(context switching)的内核机制让每个程序都感觉自己在独占处理器。私有地址空间则是通过称为虚拟内存(virtual memory)的机制让每个程序都感觉自己在独占内存。这样的抽象使得具体的进程不需要操心处理器和内存的相关适宜，也保证了在不同情况下运行同样的程序能得到相同的结果

5.父进程中创建子进程：
  
*   调用一次，但是会有两个返回值  
*   并行执行，不能预计父进程和子进程的执行顺序  
*   拥有自己独立的地址空间（也就是变量都是独立的），除此之外其他都相同  
*   在父进程和子进程中 stdout 是一样的

1.如果信号已被发送但是未被接收，那么处于等待状态(pending)，同类型的信号至多只会有一个待处理信号(pending signal)，一定要注意这个特性，因为内部实现机制不可能提供较复杂的数据结构，所以信号的接收并不是一个队列。比如说进程有一个 SIGCHLD 信号处于等待状态，那么之后进来的 SIGCHLD 信号都会被直接扔掉。

2.信号处理程序是计算机系统中并发的又一个示例 

3.不可以用信号来对其他进程中发生的事件计数 

4.利用sigprocmask来同步进程，来保证父进程能先添加子进程再删除子进程（避免两个函数竞争）p520 

5.setjmp 保存当前程序的堆栈上下文环境(stack context)，注意，这个保存的堆栈上下文环境仅在调用 setjmp 的函数内有效，如果调用 setjmp 的函数返回了，这个保存的堆栈上下文环境就失效了。调用 setjmp 的直接返回值为 0。