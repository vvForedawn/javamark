## 系统级I/O
1.nbytes < sizeof(buf) 这种情况(short counts) 是可能发生的，会在下面的情形下发生：

*  在读取的时候遇到 EOF(end-of-file)
*  从终端中读取文本行
*  读取和写入网络 sockets

但是在下面的情况下不会发生

*  从磁盘文件中读取（除 EOF 外）
*  写入到磁盘文件中

最好总是允许 short count，这样就可以避免处理这么多不同的情况

2.Unix I/O 是最通用最底层的 I/O 方法，其他的 I/O 包都是在 Unix I/O 的基础上进行构建的，值得注意的一点是，Unix I/O 中的方法都是异步信号安全(async-signal-safe)的，也就是说，可以在信号处理器中调用。因为比较底层和基础的缘故，需要处理的情况非常多，很容易出错。高效率的读写需要用到缓冲区，同样容易出错，这也就是标准 C 库着重要解决的问题。

标准 C I/O 提供了带缓存访问文件的方法，使用的时候几乎不用考虑太多，但是如果我们想要得到文件的元信息时，就还是得使用 Unix I/O 中的 stat 函数。另外标准 C I/O 中的函数都不是异步信号安全(async-signal-safe)的，所以并不能在信号处理器中使用。最后，标准 C I/O 不适合用于处理网络套接字。

3.在网络套接字上不要使用标准I/O函数来进行输入和输出。而是要使用健壮的RIO函数。如果你需要格式化的输出，使用sprintf函数在存储器中格式化一个字符串，然后用rio_writen把它发送到套接口。如果你需要格式化输入，使用rio_readlineb来读一个完整的文本行，然后用sscanf从文本行提取不同的字段。